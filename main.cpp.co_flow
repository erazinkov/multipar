#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <map>
#include <algorithm>
#include <optional>
#include <exception>
#include <cmath>
#include <numeric>

#include <TVirtualFitter.h>
#include <TLatex.h>
#include <TGraphErrors.h>
#include <TCanvas.h>
#include <TF1.h>

class my_error: public std::exception
{
public:
    my_error(const std::string& message) : _message{message}
    {}
    const char* what() const noexcept override
    {
        return _message.c_str();
    }
private:
    std::string _message;
};

class FitFunction_2
{
public:
    FitFunction_2(const std::map<int, std::vector<double>> &d, const int &aNumber)
        : _d{d}, _aNumber{aNumber} {}

    double operator() (double *x, double *par)
    {
        double arg{x[0]};
        int idx{ std::min(static_cast<int>(std::round(arg)), static_cast<int>(_d.size() - 1)) };
        double val{0.0};
        auto A{
           (par[0] - par[1] * _d.at(idx).at(0) - par[5] * (par[2] * _d.at(idx).at(1) + par[4]))
                   / (1.0 - par[5] * par[3])
        };

        if (idx < _aNumber)
        {
            val = A;
        }
        else
        {
            val = par[2] * _d.at(idx).at(1) - par[3] * A + par[4];
        }
        return val;
   }
private:
    const std::map<int, std::vector<double>> _d;
    const int _aNumber;
};

struct Data {
    enum class Value {
        A,
        W
    };
    std::optional<double> a;
    std::optional<double> w;
};


struct Points {
    std::vector<std::string> l;
    std::vector<double> x;
    std::vector<double> xErr;
    std::vector<double> y;
    std::vector<double> yErr;
};

std::vector<std::string> splitLineToStrs(const std::string &line);
std::map<std::string, std::vector<std::string>> getStrMapByChem(const std::string &fileName,
                                                                 const size_t column,
                                                                 std::map<std::string, Data> chem);
void addPointsByValue(const std::map<std::string, Data> &chem,
                      Points &points,
                      const Data::Value value);
double strToDouble(std::string str);

void calcConv(const std::shared_ptr<TF1> &f,
              const std::map<std::string, Data> &chem,
              const std::map<std::string, std::vector<std::string>> &vC,
              const std::map<std::string, std::vector<std::string>> &vO)
{
    auto p0{f.get()->GetParameter(0)};
    auto p1{f.get()->GetParameter(1)};
    auto p2{f.get()->GetParameter(2)};
    auto p3{f.get()->GetParameter(3)};
    auto p4{f.get()->GetParameter(4)};
    auto p5{f.get()->GetParameter(5)};

    auto sumA2{0.0};
    auto sumA{0.0};
    auto sumW2{0.0};
    auto sumW{0.0};
    for (const auto &item : chem)
    {
        if (item.second.a.has_value())
        {
            auto C{strToDouble(vC.at(item.first).front())};
            auto O{strToDouble(vO.at(item.first).front())};
            auto a{
                (p0 - p1 * C - p5 * (p2 * O + p4)) / (1 - p5 * p3)
            };
            auto w{
                p2 * O - p3 * a + p4
            };
            sumA2 += (item.second.a.value() - a) * (item.second.a.value() - a);
            sumA += a;
            if (item.second.w.has_value())
            {
                sumW2 += (item.second.w.value() - w) * (item.second.w.value() - w);
                sumW += w;
            }
        }
    }
    auto stdAabs{std::sqrt(sumA2 / chem.size())};
    auto stdWabs{std::sqrt(sumW2 / chem.size())};
    std::cout << "convergence" << std::endl;
    std::cout << "avgA = " << sumA / chem.size() << std::endl;
    std::cout << "stdAabs = " << stdAabs << std::endl;
    std::cout << "avgW = " << sumW / chem.size() << std::endl;
    std::cout << "stdWabs = " << stdWabs << std::endl;
}

void calcRep(const std::shared_ptr<TF1> &f,
             const std::map<std::string, Data> &chem,
             const std::map<std::string, std::vector<std::string>> &vC,
             const std::map<std::string, std::vector<std::string>> &vO)
{
    auto p0{f.get()->GetParameter(0)};
    auto p1{f.get()->GetParameter(1)};
    auto p2{f.get()->GetParameter(2)};
    auto p3{f.get()->GetParameter(3)};
    auto p4{f.get()->GetParameter(4)};
    auto p5{f.get()->GetParameter(5)};

    std::vector<double> A;
    std::vector<double> W;
    for (const auto &item : chem)
    {
        if (item.second.a.has_value())
        {
            // std::cout << item.first << " " << vC.at(item.first).front() << std::endl;
            auto C{strToDouble(vC.at(item.first).front())};
            auto O{strToDouble(vO.at(item.first).front())};
            auto a{
                (p0 - p1 * C - p5 * (p2 * O + p4)) / (1 - p5 * p3)
            };
            auto w{
                p2 * O - p3 * a + p4
            };
            A.push_back(a);
            if (item.second.w.has_value())
            {
                W.push_back(w);
            }
        }
    }

    auto avgA{std::accumulate(A.begin(), A.end(), 0.0)};
    avgA /= A.size();
    auto avgW{std::accumulate(W.begin(), W.end(), 0.0)};
    avgW /= W.size();

    auto stdAabs{TMath::RMS(A.begin(), A.end())};
    auto stdWabs{TMath::RMS(W.begin(), W.end())};
    std::cout << "repeatability" << std::endl;
    std::cout << "avgA = " << avgA << std::endl;
    std::cout << "stdAabs = " << stdAabs << std::endl;
    std::cout << "avgW = " << avgW << std::endl;
    std::cout << "stdWabs = " << stdWabs << std::endl;
}

int main()
{
    // TVirtualFitter::SetDefaultFitter("Minuit");
    const std::map<std::string, Data> chem
    {
        // { "3835_sum", {7.8, 4.2}},
        // { "3834_sum", {9.6, 5.5},},
        // { "3836_sum", {11.2, 6.2} },
        // { "3837_sum", {11.8, 3.9} },
        // { "3838_sum", {15.1, 7.9} },
        // { "3839_sum", {18.2, 4.9} },
        // { "3840_sum", {20.7, 6.7} },
        // { "3841_sum", {27.6, 8.0} },
        // { "3842_sum", {28.3, 7.8} },
        // { "3843_sum", {30.4, 8.2} },
        // { "3844_sum", {32.9, 8.1} },
       // { "bereza_1_sum", {9.3, std::nullopt} },
       { "bereza_2_sum", {12.1, std::nullopt} },
       { "bereza_3_sum", {14.1, std::nullopt} },
       { "bereza_4_sum", {16.3, std::nullopt} },
       { "bereza_5_sum", {18.1, std::nullopt} },
       { "bereza_6_sum", {19.5, std::nullopt} },
       { "bereza_7_sum", {21.8, 5.3} },
       { "bereza_8_sum", {23.7, 5.4} },
       { "bereza_9_sum", {25.6, 5.2} },
       // { "bereza_10_sum", {28.4, 5.2} },
       // { "bereza_11_sum", {30.7, 5.0} },
    };

    const std::map<std::string, Data> chemRep
        {
            // { "3834_povtor_1.", {9.6, 5.5},},
            // { "3834_povtor_2.", {9.6, 5.5},},
            // { "3834_povtor_3.", {9.6, 5.5},},
            // { "3834_povtor_4.", {9.6, 5.5},},
            // { "3834_povtor_5.", {9.6, 5.5},},
            // { "3834_povtor_6.", {9.6, 5.5},},
            // { "3834_povtor_7.", {9.6, 5.5},},
            // { "3834_povtor_8.", {9.6, 5.5},},
            // { "3834_povtor_9.", {9.6, 5.5},},
            // { "3834_povtor_10.", {9.6, 5.5},},
            // { "3834_povtor_11.", {9.6, 5.5},},
            // { "3834_povtor_12.", {9.6, 5.5},},
        // { "3838_povtor_1.", {15.1, 7.9},},
        // { "3838_povtor_2.", {15.1, 7.9},},
        // { "3838_povtor_3.", {15.1, 7.9},},
        // { "3838_povtor_4.", {15.1, 7.9},},
        // { "3838_povtor_5.", {15.1, 7.9},},
        // { "3838_povtor_6.", {15.1, 7.9},},
        // { "3838_povtor_7.", {15.1, 7.9},},
        // { "3838_povtor_8.", {15.1, 7.9},},
        // { "3838_povtor_9.", {15.1, 7.9},},
        // { "3838_povtor_10.", {15.1, 7.9},},
        // { "3838_povtor_11.", {15.1, 7.9},},
        // { "3838_povtor_12.", {15.1, 7.9},},
        { "bereza_5_povtor_1.", {18.1, 0.0} },
        { "bereza_5_povtor_2.", {18.1, 0.0} },
        { "bereza_5_povtor_3.", {18.1, 0.0} },
        { "bereza_5_povtor_4.", {18.1, 0.0} },
        { "bereza_5_povtor_5.", {18.1, 0.0} },
        { "bereza_5_povtor_6.", {18.1, 0.0} },
        { "bereza_5_povtor_7.", {18.1, 0.0} },
        { "bereza_5_povtor_8.", {18.1, 0.0} },
        { "bereza_5_povtor_9.", {18.1, 0.0} },
        { "bereza_5_povtor_10.", {18.1, 0.0} },
        { "bereza_5_povtor_11.", {18.1, 0.0} },
        { "bereza_5_povtor_12.", {18.1, 0.0} },
         };

    const std::map<std::string, size_t> elementColumn
    {
        // all
        // {"C", 3},
        // {"O", 13},
        //wo Mg
        // {"C", 3},
        // {"O", 11},
        //wo MgCa
        // {"C", 3},
        // {"O", 9},
        //wo MgCaFe
        // {"C", 3},
        // {"O", 7},
        //wo MgCaFeS
        // {"C", 3},
        // {"O", 7},
        //wo MgCaFeSN
        // {"C", 3},
        // {"O", 5},
        //wo MgCaFeSNAl
        {"C", 1},
        {"O", 3},
    };

    // const auto fileName{"rea.elts.txt_shahta12_all"};
    // const auto fileName{"rea.elts.txt_shahta12_wo_Mg"};
    // const auto fileName{"rea.elts.txt_shahta12_wo_MgCa"};
    // const auto fileName{"rea.elts.txt_shahta12_wo_MgCaFe"};
    // const auto fileName{"rea.elts.txt_shahta12_wo_MgCaFeS"};
    // const auto fileName{"rea.elts.txt_shahta12_wo_MgCaFeSN"};
    // const auto fileName{"rea.elts.txt_shahta12_wo_MgCaFeSNAl"};
    const auto fileName{"rea.elts.txt_bereza_wo_MgCaFeSNAl"};
    std::cout << fileName << std::endl;
    try
    {
        Points points;
        addPointsByValue(chem, points, Data::Value::A);
        auto aNumber{points.x.size()};
        addPointsByValue(chem, points, Data::Value::W);
        auto wNumber{points.x.size() - aNumber};
        auto vC{getStrMapByChem(fileName, elementColumn.at("C"), chem)};
        auto vO{getStrMapByChem(fileName, elementColumn.at("O"), chem)};
        std::map<int, std::vector<double>> mmn;

        size_t idx{ static_cast<size_t>(std::round(points.x.front())) };

        auto it_vC{vC.begin()};
        for (size_t i{idx}; i < idx + aNumber; ++i)
        {
            mmn[i].push_back(strToDouble((*it_vC).second.front()));
            ++it_vC;
        }
        auto it_vO{vO.begin()};
        for (size_t i{idx}; i < idx + aNumber; ++i)
        {
            mmn[i].push_back(strToDouble((*it_vO).second.front()));
            ++it_vO;
        }

        it_vC = vC.begin();
        for (size_t i{idx + aNumber}; i < idx + aNumber + wNumber; ++i)
        {
            mmn[i].push_back(strToDouble((*it_vC).second.front()));
            ++it_vC;
        }
        it_vO = vO.begin();
        for (size_t i{idx + aNumber}; i < idx + aNumber + wNumber; ++i)
        {
            mmn[i].push_back(strToDouble((*it_vO).second.front()));
            ++it_vO;
        }

        std::unique_ptr<TGraphErrors> gr{new TGraphErrors(static_cast<int>(points.x.size()), &points.x[0], &points.y[0], &points.xErr[0], &points.yErr[0])};
        gr.get()->SetMarkerSize(1.5);
        gr.get()->SetMarkerStyle(21);
        gr.get()->SetTitle(";N_{probe};[...A, ...W]");
        FitFunction_2 fObj(mmn, static_cast<int>(aNumber));
        std::shared_ptr<TF1> f{new TF1("f", fObj, points.x.front(), points.x.back(), 6)};
        f.get()->SetParameter(0, 100.0);
        f.get()->SetParameter(1, 1.0);
        f.get()->SetParameter(2, 1.0);
        f.get()->SetParameter(3, 0.5);
        f.get()->SetParameter(4, -1.0);
        f.get()->SetParameter(5, 1.0);
        f.get()->SetNpx(static_cast<int>(points.x.size()));

        gr.get()->Fit(f.get(), "R");
        gr.get()->Fit(f.get(), "R");// !!! bereza
        const std::string psName{"output.ps"};
        std::unique_ptr<TCanvas> c{new TCanvas("c", "c", 1024, 960)};
        c.get()->Print((psName + '[').c_str());
        gr.get()->Draw("APL");
        c.get()->Print(psName.c_str());
        c.get()->Print((psName + ']').c_str());

        calcConv(f, chem, vC, vO);
        auto vCRep{getStrMapByChem(fileName, elementColumn.at("C"), chemRep)};
        auto vORep{getStrMapByChem(fileName, elementColumn.at("O"), chemRep)};
        calcRep(f, chemRep, vCRep, vORep);


    }
    catch (const my_error& err)
    {
        std::cout << "Error: " << err.what() << std::endl;
    }
    catch (const std::exception& err)
    {
        std::cout << "Error: " << err.what() << std::endl;
    }
    return 0;
}



double strToDouble(std::string str)
{
    double d;
    std::stringstream ss(str);
    ss >> d;
    if (ss.fail())
    {
        throw my_error("Can\'t convert: " + str);
    }
    return d;
}

void addPointsByValue(const std::map<std::string, Data> &chem,
                        Points &points,
                        const Data::Value value)
{

    int xx{static_cast<int>(points.x.size())};
    for (auto it{chem.begin()}; it != chem.end(); ++it)
    {
        std::optional<double> v;
        switch (value) {
            case Data::Value::A:
                v = (*it).second.a;
            break;
            case Data::Value::W:
                v = (*it).second.w;
            break;
        }
        if (v.has_value())
        {
            points.l.push_back((*it).first);
            points.x.push_back(xx++);
            points.xErr.push_back(0.01);
            points.y.push_back(v.value());
            points.yErr.push_back(0.5);
        }
    }

}

std::vector<std::string>splitLineToStrs(const std::string &line)
{
    std::stringstream ss(line);
    std::string str;
    std::vector<std::string> strs;
    while (ss >> str)
    {
        strs.push_back(str);
    }
    return strs;

}

std::map<std::string, std::vector<std::string>> getStrMapByChem(const std::string &fileName,
                                                                const size_t column,
                                                                std::map<std::string, Data> chem)
{
    std::ifstream ifs(fileName);
    if (!ifs.is_open())
    {
        throw my_error("Can't open file \"" + fileName + "\"");
    }
    std::map<std::string, std::vector<std::string>> map;
    std::string line;

    while (getline(ifs, line))
    {
        auto strs{splitLineToStrs(line)};
        try
        {
            auto it = std::find_if(chem.begin(), chem.end(), [&strs] (std::pair<std::string, Data> chemItem){
                    return strs.at(0).find(chemItem.first) != std::string::npos;
            });

            if (it != chem.end())
            {
                map[(*it).first].push_back(strs.at(column));
            }
        }  catch (...) {
            std::cout << "Incorrect column " << column;
        }
    }
    return map;
}
